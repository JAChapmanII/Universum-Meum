Jun 03, 2010

Finish up what I started on dynamic particle creation, mainly figure out that damn algorithm for
mapping click X/Y to actual X/Y.

Split off repel, gravity, and point to be in a different project dir, just like the end equivalent
should work. Create a new program/new code to take the files, parse them as necessary and then
generate new output files/binaries based on the information contained within.

Implement scroll wheel support by adding in the viw width/height in addition to the actual window
width and height. This way, you can get the scroll wheel events (SDL_BUTTON_WHEELDOWN and
SDL_BUTTON_WHEELUP) as a means of zooming in and out by updating the view width/height.

2/5/10

Update the TODO, really important :D

Fix repel to use that elastic code

Fix everything now that it's all borked. To help with this, look into using less objects as that
could very well be screwing things up

1/5/10

The main thing that needs done code-wise at this point is to have the gravity and repel forces
reimplemented properly. The way we were going to do it, where you can define different polygons
and percents to apply I think would help a ton here, as we could have gravity drop off at radius
and have the repel pick up.

Other huge thing to do is separate the simulation part from the render part, such as using two
threads or anything that'll split them up.

A script that checks for basic parse errors would be nice.

Before 1/5/10

display.d:
	- Decide on the number of dimensions (a lot of OpenGL code will be different)
		Note: We could use a actor based system where display only sets up the OpenGL environment
		and then each actor then draws itself in whatever dimensions
	- Make this file and whatever it imports be able to take arbitrary objects based on some class
	  and display them in either 2 or 3 dimensions.
	- Needs to be able to get the objects added easily, have some common interface for defining how
	  shit is rendered

main.d:
	- This should look for different objects and seed conditions or something. Have the main GUI in
	  here from which the person can select a project to be compiled/run
	- Set up the main controls once a universe is loaded, zoom/save/quit/pan/rotate/fast/slow/pause
	  and everything else it might need such as changing the abstraction level.

particle.d:
	- Make it so that it holds some level of abstraction (e.g., "molecule") to class it under
	- Add some set of predefined things for it to do that can be strung together in some other file
	- Create some function called "work" or the like that is overridden in the other file

force.d:
	- Perhaps ditch in favor of allowing particles to do this?
		Note: might be best to allow forces to be created and then they can be "work"'d from a
		to allow easy duplication of wanted effect
	- Make these have a virtual "work" then?

# vim: textwidth=100: fo+=tc:
